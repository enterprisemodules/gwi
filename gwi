#!/usr/bin/env bash
#
# gwi - Git Worktree Issue CLI
# Integrates GitHub issues with git worktrees for streamlined development
#

set -euo pipefail

# Configuration
GWI_WORKTREE_BASE="${GWI_WORKTREE_BASE:-$HOME/worktrees}"
GWI_MERGE_STRATEGY="${GWI_MERGE_STRATEGY:-squash}"
GWI_AUTO_ACTIVATE="${GWI_AUTO_ACTIVATE:-0}"
GWI_HOOK_DIR="${GWI_HOOK_DIR:-$HOME/.config/gwi/hooks}"

# Colors
RED=$'\033[0;31m'
GREEN=$'\033[0;32m'
YELLOW=$'\033[0;33m'
BLUE=$'\033[0;34m'
NC=$'\033[0m' # No Color

# Helpers
die() { echo -e "${RED}Error:${NC} $*" >&2; exit 1; }
info() { echo -e "${BLUE}→${NC} $*"; }
success() { echo -e "${GREEN}✓${NC} $*"; }
warn() { echo -e "${YELLOW}!${NC} $*"; }

# Check if required commands are available
require_cmd() {
  local cmd="$1"
  local msg="${2:-}"
  if ! command -v "$cmd" &>/dev/null; then
    [[ -n "$msg" ]] && die "$msg"
    die "Required command not found: $cmd"
  fi
}

# Check if gh is authenticated
check_gh_auth() {
  if ! gh auth status &>/dev/null; then
    die "GitHub CLI not authenticated. Run: gh auth login"
  fi
}

# Check if worktree has uncommitted changes
has_uncommitted_changes() {
  local path="$1"
  (cd "$path" && [[ -n "$(git status --porcelain 2>/dev/null)" ]])
}

# Check if we're inside a worktree
is_inside_worktree() {
  local path="$1"
  local current
  current=$(pwd)
  [[ "$current" == "$path" || "$current" == "$path"/* ]]
}

# Get repository info from current directory or any parent
get_repo_info() {
  local remote_url
  remote_url=$(git config --get remote.origin.url 2>/dev/null) || die "Not in a git repository with origin remote"

  # Parse org/repo from various URL formats
  if [[ "$remote_url" =~ github\.com[:/]([^/]+)/([^/.]+)(\.git)?$ ]]; then
    GWI_ORG="${BASH_REMATCH[1]}"
    GWI_REPO="${BASH_REMATCH[2]}"
  else
    die "Could not parse GitHub org/repo from remote URL: $remote_url"
  fi
}

# Get worktree base path for current repo
get_worktree_base() {
  get_repo_info
  echo "${GWI_WORKTREE_BASE}/github.com/${GWI_ORG}/${GWI_REPO}"
}

# Slugify a string (lowercase, replace spaces/special chars with dashes)
slugify() {
  echo "$1" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9]+/-/g' | sed -E 's/^-+|-+$//g' | cut -c1-50
}

# Get issue info from GitHub
get_issue() {
  local issue_number="$1"
  check_gh_auth
  gh issue view "$issue_number" --json number,title,state 2>/dev/null || die "Issue #$issue_number not found"
}

# Find worktree path by issue number
find_worktree_by_issue() {
  local issue_number="$1"
  local base
  base=$(get_worktree_base)

  # Look for directory starting with the issue number
  find "$base" -maxdepth 1 -type d -name "${issue_number}-*" 2>/dev/null | head -1
}

# List all worktrees for current repo
list_worktrees() {
  local base
  base=$(get_worktree_base)

  if [[ -d "$base" ]]; then
    find "$base" -maxdepth 1 -mindepth 1 -type d 2>/dev/null
  fi
}

# Detect issue number from current directory
detect_issue_number() {
  local current_dir
  current_dir=$(pwd)
  local base
  base=$(get_worktree_base)

  if [[ "$current_dir" == "$base"/* ]]; then
    local dirname
    dirname=$(basename "$current_dir")
    if [[ "$dirname" =~ ^([0-9]+)- ]]; then
      echo "${BASH_REMATCH[1]}"
      return 0
    fi
  fi
  return 1
}

# Find hook script for current worktree/repo
find_hook() {
  local hook_name="${1:-activate}"
  local worktree_path="${2:-$(pwd)}"

  # 1. Check worktree-specific hook
  if [[ -x "$worktree_path/.gwi/$hook_name" ]]; then
    echo "$worktree_path/.gwi/$hook_name"
    return 0
  fi

  # 2. Check main repo hook
  local main_path
  main_path=$(git worktree list --porcelain 2>/dev/null | head -1 | sed 's/^worktree //')
  if [[ -n "$main_path" && -x "$main_path/.gwi/$hook_name" ]]; then
    echo "$main_path/.gwi/$hook_name"
    return 0
  fi

  # 3. Check global config hook
  get_repo_info 2>/dev/null || return 1
  local global_hook="${GWI_HOOK_DIR}/${GWI_ORG}/${GWI_REPO}/$hook_name"
  if [[ -x "$global_hook" ]]; then
    echo "$global_hook"
    return 0
  fi

  return 1
}

# Execute hook if found
run_hook() {
  local hook_name="${1:-activate}"
  local worktree_path="${2:-$(pwd)}"

  local hook_script
  hook_script=$(find_hook "$hook_name" "$worktree_path") || return 0

  info "Running $hook_name hook..."
  (cd "$worktree_path" && "$hook_script")
  local exit_code=$?

  if [[ $exit_code -eq 0 ]]; then
    success "Hook completed"
  else
    warn "Hook exited with code $exit_code"
  fi
  return $exit_code
}

# Get tmux session name from worktree directory
get_session_name() {
  basename "$(pwd)"
}

# Interactive issue selector (returns issue number)
select_issue() {
  local header="${1:-Select issue}"
  get_repo_info

  local issues_json
  issues_json=$(gh issue list --state open --limit 50 --json number,title 2>/dev/null) || return 1

  local count
  count=$(echo "$issues_json" | jq 'length')
  [[ "$count" -eq 0 ]] && return 1

  local selected

  if command -v fzf &>/dev/null; then
    selected=$(echo "$issues_json" | jq -r '.[] | "#\(.number) \(.title)"' | \
      fzf --height=~50% --reverse --header="$header ($GWI_ORG/$GWI_REPO)")
  else
    echo -e "Open issues for ${BLUE}$GWI_ORG/$GWI_REPO${NC}:" >&2
    echo "" >&2
    local i=1
    while IFS= read -r line; do
      echo -e "  ${YELLOW}$i)${NC} $line" >&2
      ((i++))
    done < <(echo "$issues_json" | jq -r '.[] | "#\(.number) \(.title)"')
    echo "" >&2
    read -p "Select [1-$count]: " choice
    if [[ "$choice" =~ ^[0-9]+$ ]] && (( choice >= 1 && choice <= count )); then
      selected=$(echo "$issues_json" | jq -r ".[$((choice-1))] | \"#\(.number) \(.title)\"")
    fi
  fi

  [[ -z "$selected" ]] && return 1
  echo "$selected" | sed 's/^#\([0-9]*\).*/\1/'
}

# Interactive worktree selector (returns issue number)
select_worktree() {
  local header="${1:-Select worktree}"
  local base
  base=$(get_worktree_base)

  local labels=()
  local numbers=()

  if [[ -d "$base" ]]; then
    while IFS= read -r dir; do
      [[ -z "$dir" ]] && continue
      local name
      name=$(basename "$dir")
      labels+=("$name")
      # Extract issue number from directory name
      if [[ "$name" =~ ^([0-9]+)- ]]; then
        numbers+=("${BASH_REMATCH[1]}")
      else
        numbers+=("")
      fi
    done < <(list_worktrees)
  fi

  if [[ ${#labels[@]} -eq 0 ]]; then
    get_repo_info 2>/dev/null || true
    warn "No worktrees found for ${GWI_ORG:-this repo}/${GWI_REPO:-}" >&2
    return 1
  fi

  get_repo_info
  local selected

  if command -v fzf &>/dev/null; then
    selected=$(printf '%s\n' "${labels[@]}" | \
      fzf --height=~50% --reverse --header="$header ($GWI_ORG/$GWI_REPO)")
  else
    echo -e "Worktrees for ${BLUE}$GWI_ORG/$GWI_REPO${NC}:" >&2
    echo "" >&2
    local i=1
    for label in "${labels[@]}"; do
      echo -e "  ${YELLOW}$i)${NC} $label" >&2
      ((i++))
    done
    echo "" >&2
    read -p "Select [1-${#labels[@]}]: " choice
    if [[ "$choice" =~ ^[0-9]+$ ]] && (( choice >= 1 && choice <= ${#labels[@]} )); then
      selected="${labels[$((choice-1))]}"
    fi
  fi

  [[ -z "$selected" ]] && return 1

  # Return issue number for selected worktree
  for i in "${!labels[@]}"; do
    if [[ "${labels[$i]}" == "$selected" ]]; then
      local num="${numbers[$i]}"
      [[ -z "$num" ]] && return 1
      echo "$num"
      return 0
    fi
  done
  return 1
}

# Command: create
cmd_create() {
  local issue_number="${1:-}"

  # Interactive selection if no argument provided
  if [[ -z "$issue_number" ]]; then
    issue_number=$(select_issue "Select issue to create worktree") || die "No issue selected"
  fi

  get_repo_info

  info "Fetching issue #$issue_number..."
  local issue_json
  issue_json=$(get_issue "$issue_number")

  local title state
  title=$(echo "$issue_json" | jq -r '.title')
  state=$(echo "$issue_json" | jq -r '.state')

  [[ "$state" == "CLOSED" ]] && warn "Issue #$issue_number is closed"

  local slug branch_name worktree_path
  slug=$(slugify "$title")
  branch_name="${issue_number}-${slug}"
  worktree_path="$(get_worktree_base)/${branch_name}"

  # Check if worktree already exists
  if [[ -d "$worktree_path" ]]; then
    warn "Worktree already exists at: $worktree_path"
    echo "$worktree_path"
    return 0
  fi

  info "Fetching from origin..."
  git fetch origin

  # Create worktree directory structure
  mkdir -p "$(dirname "$worktree_path")"

  # Check if branch already exists (local or remote)
  if git show-ref --verify --quiet "refs/heads/$branch_name" 2>/dev/null; then
    info "Using existing local branch: $branch_name"
    git worktree add "$worktree_path" "$branch_name"
  elif git show-ref --verify --quiet "refs/remotes/origin/$branch_name" 2>/dev/null; then
    info "Using existing remote branch: $branch_name"
    git worktree add "$worktree_path" -b "$branch_name" "origin/$branch_name"
  else
    info "Creating worktree: $branch_name"
    git worktree add "$worktree_path" -b "$branch_name" origin/main
  fi

  success "Worktree created at: $worktree_path"
  echo ""
  echo "  cd $worktree_path"
}

# Internal command: _start (select issue interactively, returns worktree path)
cmd__start() {
  get_repo_info

  info "Fetching open issues..."
  local issues_json
  issues_json=$(gh issue list --state open --limit 50 --json number,title 2>/dev/null) || die "Failed to fetch issues"

  local count
  count=$(echo "$issues_json" | jq 'length')

  if [[ "$count" -eq 0 ]]; then
    echo "No open issues found." >&2
    return 1
  fi

  local selected

  # Use fzf if available
  if command -v fzf &>/dev/null; then
    selected=$(echo "$issues_json" | jq -r '.[] | "#\(.number) \(.title)"' | \
      fzf --height=~50% --reverse --header="Select issue to work on ($GWI_ORG/$GWI_REPO)")
  else
    # Fallback to numbered selection
    echo -e "Open issues for ${BLUE}$GWI_ORG/$GWI_REPO${NC}:" >&2
    echo "" >&2

    local i=1
    while IFS= read -r line; do
      echo -e "  ${YELLOW}$i)${NC} $line" >&2
      ((i++))
    done < <(echo "$issues_json" | jq -r '.[] | "#\(.number) \(.title)"')

    echo "" >&2
    read -p "Select [1-$count]: " choice

    if [[ "$choice" =~ ^[0-9]+$ ]] && (( choice >= 1 && choice <= count )); then
      selected=$(echo "$issues_json" | jq -r ".[$((choice-1))] | \"#\(.number) \(.title)\"")
    fi
  fi

  if [[ -z "$selected" ]]; then
    return 1
  fi

  # Extract issue number from selection
  local issue_number
  issue_number=$(echo "$selected" | sed 's/^#\([0-9]*\).*/\1/')

  # Create the worktree (reuse cmd_create logic but return path)
  local issue_json title slug branch_name worktree_path

  issue_json=$(get_issue "$issue_number")
  title=$(echo "$issue_json" | jq -r '.title')
  slug=$(slugify "$title")
  branch_name="${issue_number}-${slug}"
  worktree_path="$(get_worktree_base)/${branch_name}"

  # Check if worktree already exists
  if [[ -d "$worktree_path" ]]; then
    echo "$worktree_path"
    return 0
  fi

  info "Fetching from origin..." >&2
  git fetch origin >&2

  mkdir -p "$(dirname "$worktree_path")"

  # Check if branch already exists (local or remote)
  if git show-ref --verify --quiet "refs/heads/$branch_name" 2>/dev/null; then
    info "Using existing local branch: $branch_name" >&2
    git worktree add "$worktree_path" "$branch_name" >&2
  elif git show-ref --verify --quiet "refs/remotes/origin/$branch_name" 2>/dev/null; then
    info "Using existing remote branch: $branch_name" >&2
    git worktree add "$worktree_path" -b "$branch_name" "origin/$branch_name" >&2
  else
    info "Creating worktree: $branch_name" >&2
    git worktree add "$worktree_path" -b "$branch_name" origin/main >&2
  fi

  success "Worktree created!" >&2
  echo "$worktree_path"
}

# Command: pr
cmd_pr() {
  local issue_number="${1:-}"

  # Try to detect from current directory, then interactive selection
  if [[ -z "$issue_number" ]]; then
    issue_number=$(detect_issue_number) || \
      issue_number=$(select_worktree "Select worktree for PR") || \
      die "No worktree selected"
  fi

  get_repo_info

  local worktree_path
  worktree_path=$(find_worktree_by_issue "$issue_number")
  [[ -z "$worktree_path" ]] && die "No worktree found for issue #$issue_number"

  # Check for uncommitted changes
  if has_uncommitted_changes "$worktree_path"; then
    warn "Worktree has uncommitted changes"
    echo -e "  ${YELLOW}$(cd "$worktree_path" && git status --short | head -5)${NC}"
    read -p "Continue anyway? [y/N]: " confirm
    [[ "$confirm" != "y" && "$confirm" != "Y" ]] && die "Aborted. Commit your changes first."
  fi

  local branch_name
  branch_name=$(basename "$worktree_path")

  info "Fetching issue #$issue_number..."
  local issue_json title
  issue_json=$(get_issue "$issue_number")
  title=$(echo "$issue_json" | jq -r '.title')

  # Push from within the worktree
  info "Pushing branch: $branch_name"
  (cd "$worktree_path" && git push -u origin "$branch_name")

  # Create PR
  info "Creating pull request..."
  local pr_url
  pr_url=$(cd "$worktree_path" && gh pr create \
    --title "$title" \
    --body "Closes #$issue_number" \
    --head "$branch_name")

  success "Pull request created: $pr_url"

  # Remove worktree
  info "Removing worktree..."
  git worktree remove "$worktree_path"

  success "Done! PR is ready for review."
}

# Command: merge
cmd_merge() {
  local issue_number="${1:-}"

  # Try to detect from current directory, then interactive selection
  if [[ -z "$issue_number" ]]; then
    issue_number=$(detect_issue_number) || \
      issue_number=$(select_worktree "Select worktree to merge") || \
      die "No worktree selected"
  fi

  get_repo_info

  local worktree_path branch_name
  worktree_path=$(find_worktree_by_issue "$issue_number")

  if [[ -n "$worktree_path" ]]; then
    branch_name=$(basename "$worktree_path")
  else
    # Try to find the branch name from a PR
    branch_name=$(gh pr list --state open --json headRefName,number | jq -r ".[] | select(.number == $issue_number) | .headRefName" 2>/dev/null)
    [[ -z "$branch_name" ]] && die "No worktree or PR found for issue #$issue_number"
  fi

  # Find the PR number for this branch
  local pr_number
  pr_number=$(gh pr list --head "$branch_name" --json number --jq '.[0].number' 2>/dev/null)
  [[ -z "$pr_number" ]] && die "No PR found for branch: $branch_name"

  # Check PR status (mergeable, checks)
  local pr_status
  pr_status=$(gh pr view "$pr_number" --json mergeable,mergeStateStatus,statusCheckRollup 2>/dev/null)

  local mergeable merge_state
  mergeable=$(echo "$pr_status" | jq -r '.mergeable')
  merge_state=$(echo "$pr_status" | jq -r '.mergeStateStatus')

  if [[ "$mergeable" == "CONFLICTING" ]]; then
    die "PR #$pr_number has merge conflicts. Resolve them first."
  fi

  if [[ "$merge_state" == "BLOCKED" ]]; then
    warn "PR #$pr_number is blocked (required checks or reviews pending)"
    read -p "Continue anyway? [y/N]: " confirm
    [[ "$confirm" != "y" && "$confirm" != "Y" ]] && die "Aborted"
  fi

  # Check for failing CI
  local check_status
  check_status=$(echo "$pr_status" | jq -r '.statusCheckRollup[]? | select(.conclusion == "FAILURE") | .name' 2>/dev/null | head -3)
  if [[ -n "$check_status" ]]; then
    warn "PR #$pr_number has failing checks:"
    echo "$check_status" | while read -r check; do echo "  - $check"; done
    read -p "Continue anyway? [y/N]: " confirm
    [[ "$confirm" != "y" && "$confirm" != "Y" ]] && die "Aborted"
  fi

  # Get the last commit message to post as issue comment
  local last_commit_msg
  if [[ -n "$worktree_path" && -d "$worktree_path" ]]; then
    last_commit_msg=$(cd "$worktree_path" && git log -1 --pretty=%B)
  else
    last_commit_msg=$(git log -1 --pretty=%B "origin/$branch_name" 2>/dev/null)
  fi

  # Post summary comment to the issue
  if [[ -n "$last_commit_msg" ]]; then
    info "Adding summary to issue #$issue_number..."
    gh issue comment "$issue_number" --body "**Merged in PR #$pr_number**

$last_commit_msg"
  fi

  info "Merging PR #$pr_number ($GWI_MERGE_STRATEGY)..."
  gh pr merge "$pr_number" "--$GWI_MERGE_STRATEGY" --delete-branch

  # Remove worktree if it exists
  if [[ -n "$worktree_path" && -d "$worktree_path" ]]; then
    info "Removing worktree..."
    git worktree remove "$worktree_path" 2>/dev/null || git worktree remove "$worktree_path" --force
  fi

  # Clean up local branch
  git branch -D "$branch_name" 2>/dev/null || true

  success "PR merged and cleaned up!"
}

# Command: rm
cmd_rm() {
  local issue_number="${1:-}"
  local force=""

  # Check for --force flag
  for arg in "$@"; do
    [[ "$arg" == "--force" || "$arg" == "-f" ]] && force="--force"
  done

  # Always show interactive selection for rm (no auto-detect)
  if [[ -z "$issue_number" || "$issue_number" == "--force" || "$issue_number" == "-f" ]]; then
    issue_number=$(select_worktree "Select worktree to remove") || return 1
  fi

  local worktree_path
  worktree_path=$(find_worktree_by_issue "$issue_number")
  [[ -z "$worktree_path" ]] && die "No worktree found for issue #$issue_number"

  local worktree_name
  worktree_name=$(basename "$worktree_path")

  # Check if we're inside the worktree we're trying to remove
  local need_cd=""
  if is_inside_worktree "$worktree_path"; then
    warn "You are inside the worktree you want to remove"
    need_cd="yes"
  fi

  # Confirm removal
  echo -e "Remove worktree ${YELLOW}$worktree_name${NC}?"
  read -p "Confirm [y/N]: " confirm
  [[ "$confirm" != "y" && "$confirm" != "Y" ]] && die "Aborted"

  # If we're inside, we need to cd out first (print instruction for shell function)
  if [[ -n "$need_cd" ]]; then
    local main_path
    main_path=$(git worktree list --porcelain 2>/dev/null | head -1 | sed 's/^worktree //')
    echo "__GWI_CD_TO__:$main_path"
  fi

  info "Removing worktree: $worktree_path"

  if [[ -n "$force" ]]; then
    git worktree remove "$worktree_path" --force
  else
    git worktree remove "$worktree_path" || die "Worktree has uncommitted changes. Use --force to remove anyway."
  fi

  success "Worktree removed."
}

# Command: status - show status of all worktrees
cmd_status() {
  get_repo_info
  local base
  base=$(get_worktree_base)

  echo -e "${GREEN}gwi status${NC} for ${BLUE}$GWI_ORG/$GWI_REPO${NC}"
  echo ""

  if [[ ! -d "$base" ]]; then
    echo "No worktrees found."
    return 0
  fi

  local has_worktrees=""
  while IFS= read -r dir; do
    [[ -z "$dir" ]] && continue
    has_worktrees="yes"

    local name branch_name issue_number
    name=$(basename "$dir")
    branch_name="$name"

    # Extract issue number
    if [[ "$name" =~ ^([0-9]+)- ]]; then
      issue_number="${BASH_REMATCH[1]}"
    else
      issue_number=""
    fi

    # Check git status
    local status_icon changes
    if has_uncommitted_changes "$dir"; then
      status_icon="${YELLOW}●${NC}"
      changes=$(cd "$dir" && git status --short | wc -l | tr -d ' ')
      changes=" (${changes} changes)"
    else
      status_icon="${GREEN}●${NC}"
      changes=""
    fi

    # Check if branch is pushed
    local push_status=""
    local ahead_behind
    ahead_behind=$(cd "$dir" && git rev-list --left-right --count "origin/$branch_name...HEAD" 2>/dev/null) || ahead_behind=""
    if [[ -n "$ahead_behind" ]]; then
      local ahead behind
      ahead=$(echo "$ahead_behind" | cut -f2)
      behind=$(echo "$ahead_behind" | cut -f1)
      [[ "$ahead" -gt 0 ]] && push_status=" ↑$ahead"
      [[ "$behind" -gt 0 ]] && push_status="$push_status ↓$behind"
    fi

    # Check PR status
    local pr_status=""
    if [[ -n "$issue_number" ]]; then
      local pr_number
      pr_number=$(gh pr list --head "$branch_name" --json number --jq '.[0].number' 2>/dev/null)
      if [[ -n "$pr_number" ]]; then
        local pr_state
        pr_state=$(gh pr view "$pr_number" --json state --jq '.state' 2>/dev/null)
        case "$pr_state" in
          OPEN)   pr_status=" ${BLUE}PR #$pr_number${NC}" ;;
          MERGED) pr_status=" ${GREEN}PR #$pr_number merged${NC}" ;;
          CLOSED) pr_status=" ${RED}PR #$pr_number closed${NC}" ;;
        esac
      else
        pr_status=" ${YELLOW}no PR${NC}"
      fi
    fi

    echo -e "  $status_icon $name$changes$push_status$pr_status"
  done < <(list_worktrees)

  if [[ -z "$has_worktrees" ]]; then
    echo "No worktrees found."
  fi
}

# Command: clean - remove orphaned worktrees and branches
cmd_clean() {
  get_repo_info

  info "Checking for orphaned worktrees..."

  # Prune worktrees that no longer exist on disk
  local pruned
  pruned=$(git worktree prune -v 2>&1)
  if [[ -n "$pruned" && "$pruned" != *"nothing"* ]]; then
    echo "$pruned"
  fi

  # Find merged branches that can be cleaned up
  info "Checking for merged branches..."
  git fetch origin --prune

  local base
  base=$(get_worktree_base)
  local branches_to_delete=()

  # Find local branches that track deleted remotes or are fully merged
  while IFS= read -r branch; do
    [[ -z "$branch" ]] && continue
    [[ "$branch" == "main" || "$branch" == "master" ]] && continue

    # Check if branch has a worktree
    local has_worktree=""
    if [[ -d "$base/$branch" ]]; then
      has_worktree="yes"
    fi

    # Check if remote branch exists
    if ! git show-ref --verify --quiet "refs/remotes/origin/$branch" 2>/dev/null; then
      if [[ -z "$has_worktree" ]]; then
        branches_to_delete+=("$branch (remote deleted)")
      fi
    fi
  done < <(git branch --format='%(refname:short)' 2>/dev/null)

  if [[ ${#branches_to_delete[@]} -eq 0 ]]; then
    success "No orphaned branches found."
    return 0
  fi

  echo ""
  echo "Branches to clean up:"
  for branch in "${branches_to_delete[@]}"; do
    echo "  - $branch"
  done
  echo ""

  read -p "Delete these branches? [y/N]: " confirm
  [[ "$confirm" != "y" && "$confirm" != "Y" ]] && return 0

  for branch_info in "${branches_to_delete[@]}"; do
    local branch
    branch=$(echo "$branch_info" | cut -d' ' -f1)
    git branch -D "$branch" 2>/dev/null && success "Deleted branch: $branch"
  done
}

# Internal command: _main (returns path to main repository)
cmd__main() {
  # Get the main worktree path (first entry in git worktree list)
  local main_path
  main_path=$(git worktree list --porcelain 2>/dev/null | head -1 | sed 's/^worktree //')

  if [[ -z "$main_path" || ! -d "$main_path" ]]; then
    die "Could not find main repository"
  fi

  echo "$main_path"
}

# Internal command: _cd (returns path for shell function to cd to)
cmd__cd() {
  local pattern="${1:-}"
  local base
  base=$(get_worktree_base)

  # No pattern - show interactive selector
  if [[ -z "$pattern" ]]; then
    local issue_number
    issue_number=$(select_worktree "Select worktree") || die "No worktree selected"
    local worktree_path
    worktree_path=$(find_worktree_by_issue "$issue_number")
    echo "$worktree_path"
    return 0
  fi

  # Exact match by issue number
  if [[ "$pattern" =~ ^[0-9]+$ ]]; then
    local exact_match
    exact_match=$(find_worktree_by_issue "$pattern")
    if [[ -n "$exact_match" ]]; then
      echo "$exact_match"
      return 0
    fi
  fi

  # Fuzzy match
  local matches=()
  local match_names=()
  while IFS= read -r dir; do
    [[ -z "$dir" ]] && continue
    local name
    name=$(basename "$dir")
    if [[ "$name" == *"$pattern"* ]]; then
      matches+=("$dir")
      match_names+=("$name")
    fi
  done < <(list_worktrees)

  case ${#matches[@]} in
    0)
      die "No worktree found matching: $pattern"
      ;;
    1)
      echo "${matches[0]}"
      ;;
    *)
      get_repo_info
      local selected

      if command -v fzf &>/dev/null; then
        selected=$(printf '%s\n' "${match_names[@]}" | \
          fzf --height=~50% --reverse --header="Multiple matches ($GWI_ORG/$GWI_REPO)")
      else
        echo "Multiple matches found:" >&2
        local i=1
        for match in "${match_names[@]}"; do
          echo "  $i) $match" >&2
          ((i++))
        done
        echo "" >&2
        read -p "Select [1-${#matches[@]}]: " choice
        if [[ "$choice" =~ ^[0-9]+$ ]] && (( choice >= 1 && choice <= ${#matches[@]} )); then
          selected="${match_names[$((choice-1))]}"
        fi
      fi

      [[ -z "$selected" ]] && die "No selection made"

      for i in "${!match_names[@]}"; do
        if [[ "${match_names[$i]}" == "$selected" ]]; then
          echo "${matches[$i]}"
          return 0
        fi
      done
      die "Invalid selection"
      ;;
  esac
}

# Internal command: _list (interactive selector, returns path)
cmd__list() {
  local base main_path
  base=$(get_worktree_base)
  main_path=$(git worktree list --porcelain 2>/dev/null | head -1 | sed 's/^worktree //')

  local labels=()
  local paths=()

  # Add main as first option
  if [[ -n "$main_path" && -d "$main_path" ]]; then
    labels+=("main ($(basename "$main_path"))")
    paths+=("$main_path")
  fi

  # Add issue worktrees
  if [[ -d "$base" ]]; then
    while IFS= read -r dir; do
      [[ -z "$dir" ]] && continue
      local name
      name=$(basename "$dir")
      labels+=("$name")
      paths+=("$dir")
    done < <(list_worktrees)
  fi

  if [[ ${#labels[@]} -eq 0 ]]; then
    echo "No worktrees found." >&2
    return 1
  fi

  get_repo_info
  local selected

  # Use fzf if available for nice arrow-key navigation
  if command -v fzf &>/dev/null; then
    selected=$(printf '%s\n' "${labels[@]}" | fzf --height=~50% --reverse --header="Worktrees for $GWI_ORG/$GWI_REPO")
  else
    # Fallback to numbered selection
    echo -e "Worktrees for ${BLUE}$GWI_ORG/$GWI_REPO${NC}:" >&2
    echo "" >&2

    local i=1
    for label in "${labels[@]}"; do
      echo -e "  ${YELLOW}$i)${NC} $label" >&2
      ((i++))
    done

    echo "" >&2
    read -p "Select [1-${#labels[@]}]: " choice

    if [[ "$choice" =~ ^[0-9]+$ ]] && (( choice >= 1 && choice <= ${#labels[@]} )); then
      selected="${labels[$((choice-1))]}"
    fi
  fi

  # Find the path for the selected label
  if [[ -n "$selected" ]]; then
    for i in "${!labels[@]}"; do
      if [[ "${labels[$i]}" == "$selected" ]]; then
        echo "${paths[$i]}"
        return 0
      fi
    done
  fi

  return 1
}

# Command: list (display only, no selection)
cmd_list() {
  local base main_path
  base=$(get_worktree_base)
  main_path=$(git worktree list --porcelain 2>/dev/null | head -1 | sed 's/^worktree //')

  get_repo_info
  echo -e "Worktrees for ${BLUE}$GWI_ORG/$GWI_REPO${NC}:"
  echo ""

  # Show main
  if [[ -n "$main_path" && -d "$main_path" ]]; then
    echo -e "  ${GREEN}main${NC} ($(basename "$main_path"))"
  fi

  # Show issue worktrees
  if [[ -d "$base" ]]; then
    while IFS= read -r dir; do
      [[ -z "$dir" ]] && continue
      local name
      name=$(basename "$dir")
      echo "  $name"
    done < <(list_worktrees)
  fi
}

# Command: activate - run setup hook
cmd_activate() {
  local worktree_path="${1:-$(pwd)}"

  local hook_script
  hook_script=$(find_hook "activate" "$worktree_path") || true

  if [[ -z "$hook_script" ]]; then
    warn "No activate hook found"
    echo "Create one of:"
    echo "  .gwi/activate (in worktree or main repo)"
    echo "  $GWI_HOOK_DIR/<org>/<repo>/activate"
    return 1
  fi

  run_hook "activate" "$worktree_path"
}

# Command: up - start dev server in tmux session
cmd_up() {
  require_cmd tmux "tmux is required for 'gwi up'. Install with: brew install tmux"

  local session_name
  session_name=$(get_session_name)

  # Check if session already exists
  if tmux has-session -t "$session_name" 2>/dev/null; then
    info "Session '$session_name' already running"
    echo "  gwi logs    # to view"
    echo "  gwi down    # to stop"
    return 0
  fi

  # Find the 'up' hook
  local up_script
  up_script=$(find_hook "up") || true

  if [[ -z "$up_script" ]]; then
    die "No 'up' hook found. Create .gwi/up with your server start command."
  fi

  info "Starting server in tmux session: $session_name"
  tmux new-session -d -s "$session_name" -c "$(pwd)" "'$up_script'"
  success "Server started"
  echo "  gwi logs    # to view"
  echo "  gwi down    # to stop"
}

# Command: down - stop dev server
cmd_down() {
  local session_name
  session_name=$(get_session_name)

  if ! tmux has-session -t "$session_name" 2>/dev/null; then
    warn "No session '$session_name' running"
    return 1
  fi

  info "Stopping session: $session_name"
  tmux kill-session -t "$session_name"
  success "Server stopped"
}

# Command: logs - attach to tmux session
cmd_logs() {
  local session_name
  session_name=$(get_session_name)

  if ! tmux has-session -t "$session_name" 2>/dev/null; then
    die "No session '$session_name' running. Start with: gwi up"
  fi

  info "Attaching to session (Ctrl+B D to detach)"
  tmux attach-session -t "$session_name"
}

# Command: help
cmd_help() {
  cat <<EOF
${GREEN}gwi${NC} - Git Worktree Issue CLI

${YELLOW}USAGE:${NC}
    gwi <command> [arguments]

${YELLOW}COMMANDS:${NC}
    start                    Select open issue and create worktree
    create [issue-number]    Create worktree (interactive if no arg)
    pr [issue-number]        Push and create PR (interactive if no arg)
    merge [issue-number]     Merge PR and cleanup (interactive if no arg)
    rm [issue-number]        Delete worktree (interactive if no arg)
    cd [number|pattern]      Navigate to worktree (interactive if no arg)
    main                     Navigate back to main repository
    list                     Interactive worktree selector (includes main)
    status                   Show status of all worktrees
    clean                    Remove orphaned worktrees and branches
    activate                 Run setup hook (install deps, etc.)
    up                       Start dev server in tmux session
    down                     Stop the dev server tmux session
    logs                     Attach to tmux session to view logs
    init                     Output shell integration code

${YELLOW}ENVIRONMENT:${NC}
    GWI_WORKTREE_BASE        Base directory for worktrees (default: ~/worktrees)
    GWI_MERGE_STRATEGY       Merge strategy: squash|merge|rebase (default: squash)
    GWI_AUTO_ACTIVATE        Auto-run activate hook on cd/start (default: 0)
    GWI_HOOK_DIR             Global hooks directory (default: ~/.config/gwi/hooks)

${YELLOW}HOOKS:${NC}
    Hooks are executable scripts searched in order:
      1. <worktree>/.gwi/<hook>      Per-worktree override
      2. <main-repo>/.gwi/<hook>     Per-project hook (recommended)
      3. ~/.config/gwi/hooks/<org>/<repo>/<hook>  Global fallback

    Hook types:
      activate    Setup script (install deps, configure env)
      up          Command to start dev server (runs in tmux)

${YELLOW}EXAMPLES:${NC}
    gwi start                Select open issue and start working
    gwi create               Select issue interactively, create worktree
    gwi create 42            Create worktree for issue #42
    gwi activate             Run setup hook (install deps)
    gwi up                   Start dev server in tmux session
    gwi logs                 View server logs (Ctrl+B D to detach)
    gwi down                 Stop the dev server
    gwi cd                   Select worktree interactively
    gwi cd 42                Navigate to worktree for issue #42
    gwi cd auth              Navigate to worktree matching "auth"
    gwi main                 Navigate back to main repository
    gwi list                 Select worktree interactively (includes main)
    gwi pr                   Select worktree, create PR
    gwi merge                Select worktree, merge its PR
    gwi rm                   Select worktree to remove
    gwi rm --force           Force remove current worktree
    gwi status               Show status of all worktrees with PR info
    gwi clean                Clean up orphaned branches

${YELLOW}SHELL INTEGRATION:${NC}
    Add to ~/.zshrc or ~/.bashrc:  eval "\$(gwi init zsh)"

EOF
}

# Command: init - output shell integration code
cmd_init() {
  # Use echo instead of cat for compatibility when PATH is incomplete
  echo '# gwi - Git Worktree Issue CLI shell integration
gwi() {
  if [[ "$1" == "cd" ]]; then
    shift
    local path=$(command gwi _cd "$@")
    if [[ -d "$path" ]]; then
      cd "$path"
      [[ "${GWI_AUTO_ACTIVATE:-0}" == "1" ]] && command gwi activate 2>/dev/null
    else
      echo "Not found" >&2
    fi
  elif [[ "$1" == "main" ]]; then
    local path=$(command gwi _main)
    [[ -d "$path" ]] && cd "$path" || echo "Not found" >&2
  elif [[ "$1" == "list" ]]; then
    local path=$(command gwi _list)
    if [[ -n "$path" && -d "$path" ]]; then
      cd "$path"
      [[ "${GWI_AUTO_ACTIVATE:-0}" == "1" ]] && command gwi activate 2>/dev/null
    fi
  elif [[ "$1" == "start" ]]; then
    local path=$(command gwi _start)
    if [[ -n "$path" && -d "$path" ]]; then
      cd "$path"
      [[ "${GWI_AUTO_ACTIVATE:-0}" == "1" ]] && command gwi activate 2>/dev/null
    fi
  elif [[ "$1" == "rm" ]]; then
    local output=$(command gwi rm "${@:2}")
    echo "$output" | grep -v "^__GWI_CD_TO__:"
    local cd_path=$(echo "$output" | grep "^__GWI_CD_TO__:" | cut -d: -f2)
    [[ -n "$cd_path" && -d "$cd_path" ]] && cd "$cd_path"
  else
    command gwi "$@"
  fi
}'
}

# Main entry point
main() {
  local cmd="${1:-help}"
  shift || true

  case "$cmd" in
    create)    cmd_create "$@" ;;
    start)     cmd__start "$@" ;;
    _start)    cmd__start "$@" ;;
    pr)        cmd_pr "$@" ;;
    merge)     cmd_merge "$@" ;;
    rm)        cmd_rm "$@" ;;
    _cd)       cmd__cd "$@" ;;
    _main)     cmd__main "$@" ;;
    _list)     cmd__list "$@" ;;
    list|ls)   cmd__list "$@" ;;
    status)    cmd_status "$@" ;;
    clean)     cmd_clean "$@" ;;
    activate)  cmd_activate "$@" ;;
    up)        cmd_up "$@" ;;
    down)      cmd_down "$@" ;;
    logs)      cmd_logs "$@" ;;
    init)      cmd_init "$@" ;;
    help|-h|--help) cmd_help ;;
    *)         die "Unknown command: $cmd. Run 'gwi help' for usage." ;;
  esac
}

main "$@"
